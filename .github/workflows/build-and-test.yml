name: Build and Test
on:
  pull_request:
  push:
    branches:
      - dev
env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
defaults:
  run:
    shell: bash
jobs:
  build_test:
    runs-on: ${{ matrix.os }}
    name: Build and Test
    strategy:
      matrix:
        #directory: ['.', 'NuGetTest']
        #os: [ubuntu-latest, windows-latest]
        directory: ['NuGetTest']
        os: [windows-latest]
      fail-fast: false
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core 6.0
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.*
    - name: Submodule Init
      run: |
        git submodule init && git submodule update
    - name: Build and Static Code Analysis
      run: |
        cd "${{matrix.directory}}"
        npm install pnpm -g
        [ -f src/Utilities/Lombiq.Gulp.Extensions/Lombiq.Gulp.Extensions.csproj ] &&
            dotnet build src/Utilities/Lombiq.Gulp.Extensions/Lombiq.Gulp.Extensions.csproj --configuration Release
        dotnet build *.sln \
          --configuration Release \
          -warnaserror \
          -p:TreatWarningsAsErrors=true \
          -p:RunAnalyzersDuringBuild=true \
          -p:NoWarn='"1591;CA1014"'\
          -nologo \
          -consoleLoggerParameters:NoSummary \
          -verbosity:quiet
    - name: Prepare SQL Server Docker image cache folder
      run: mkdir --parents ~/sql-server-docker-image-cache
    - name: Cache SQL Server Docker images
      id: sql-server-docker-image-cache
      uses: actions/cache@v3
      with:
        path: ~/sql-server-docker-image-cache
        key: sql-server-docker-image-cache-${{ runner.os }}-${{ hashFiles('*.tar') }}
        restore-keys: |
          npm-feature-${{ hashFiles('package-lock.json') }}
    - name: Set up SQL Server
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
            if [ ${{ steps.sql-server-docker-image-cache.outputs.cache-hit != "true" }}]; then
                docker pull mcr.microsoft.com/mssql/server
                docker save --output ~/sql-server-docker-image-cache/sql-server.tar mcr.microsoft.com/mssql/server
            else
                docker load --input --quiet ~/sql-server-docker-image-cache/sql-server.tar
            fi

            docker run --name sql2019 -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1!' -p 1433:1433 -d 'mcr.microsoft.com/mssql/server:2019-latest'
            docker exec -u 0 sql2019 bash -c 'mkdir /data; chmod 777 /data -R; chown mssql:root /data'
        else
          # There's no official Windows Docker image for SQL Server anymore:
          # https://github.com/microsoft/mssql-docker/issues/718. The links under
          # https://hub.docker.com/_/microsoft-mssql-servera to Windows images are broken. You can actually run Linux
          # images on Windows, but not on GitHub-hosted agents:
          # https://github.com/actions/virtual-environments/issues/252. So, we use this image:
          # https://hub.docker.com/r/tobiasfenster/mssql-server-dev-unsupported. Another one:
          # https://hub.docker.com/r/willh/mssql-server-windows-developer.
          docker pull tobiasfenster/mssql-server-dev-unsupported:2019-latest
          docker run --name sql2019 -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1!' -p 1433:1433 -d 'tobiasfenster/mssql-server-dev-unsupported:2019-latest'
        fi

        maxTryCount=10
        
        for i in $(seq 1 $maxTryCount); do
            echo "Waiting for SQL Server to start. Attempt $i/$maxTryCount."

            sqlServerIsStarted=false
            
            # To prevent the step from failing on the first non-zero exit code, we need to put the commands into the
            # ifs, see: https://github.community/t/github-action-terminates-on-first-non-zero-exit-code/240701/2.
            if sqlcmd -b -U sa -P 'Password1!' -Q "SELECT @@SERVERNAME as ServerName" &> /dev/null; then
                sqlServerIsStarted=true
            fi

            if [ "$sqlServerIsStarted" = true ]; then
                echo "SQL Server is successfully started."
                break
            else
                if [ $i != $maxTryCount ]; then
                    echo "SQL Server is not ready. Waiting for 1s."
                    sleep 1
                else
                    echo "SQL Server couldn't be started."
                    sqlcmd -b -Q "SELECT @@SERVERNAME as ServerName"
                    exit 1;
                fi
            fi
        done
    - name: Set up Azurite via NPM
      run: |
        npm install -g azurite
        azurite --silent --location ${{matrix.directory}}/azurite --debug ${{matrix.directory}}/azurite/debug.log &
    - name: Tests
      # This step gets the list of all projects, selects the test projects (excluding the two test libraries) and then
      # uses sed to create an inline bash script. What this script does:
      # - Uses 'dotnet test -c Release --no-restore --no-build' to start up each project.
      # - The test output is wrapped by '::group::<project name>' before and '::endgroup::' after it. This tells GitHub
      #   to place each test's output into a collapsible region on the Actions web UI.
      # - Each call is connected with '&&', so it stops on the first test failure to save computational resources.
      #
      # The script is evaluated by bash and the output is passed through grep to filter out some IPv6 related garbage
      # data produced by chromedriver. The trouble is, this way the final error code will be grep's and not the test
      # run's, so to get around this 'SUCCESS' or 'FAILURE' is written into the .ui_test_result file before the output
      # is sent to grep. The final line sets the result according to what was written into the .ui_test_result file.
      run: |
        export Lombiq_Tests_UI__SqlServerDatabaseConfiguration__ConnectionStringTemplate="Server=.;Database=LombiqUITestingToolbox_{{id}};User Id=sa;Password=Password1!;MultipleActiveResultSets=True;Connection Timeout=60;ConnectRetryCount=15;ConnectRetryInterval=5"
        export Lombiq_Tests_UI__DockerConfiguration__ContainerName="sql2019"

        cd "${{matrix.directory}}"

        (dotnet sln list |
            grep '.Tests.' |
            grep -v 'Lombiq.Tests.UI.csproj' |
            grep -v 'Lombiq.Tests.csproj' |
            sed -e 's/\\/\//g' \
                -e '$atrue' \
                -e 's/\(.*\)/echo "::group::\1" \&\&\ndotnet test -c Release --no-restore --no-build '"'\\1'"' \&\&\necho "::endgroup::" \&\&/' |
            bash && (echo SUCCESS > .ui_test_result) || (echo FAIL > .ui_test_result)) |
            grep -v '^Connection refused \[::ffff:127.0.0.1\]';
        grep SUCCESS .ui_test_result
    - uses: actions/upload-artifact@v2
      if: hashFiles(format('{0}/test/**/FailureDumps', matrix.directory))
      with:
          name: ui-test-failure-dump
          path: format('{0}/test/**/FailureDumps', matrix.directory)
